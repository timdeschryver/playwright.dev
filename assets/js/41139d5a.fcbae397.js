"use strict";(self.webpackChunkplaywright_dev=self.webpackChunkplaywright_dev||[]).push([[7644],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return d}});var n=a(67294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),g=p(a),d=s,m=g["".concat(l,".").concat(d)]||g[d]||c[d]||r;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function d(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,o=new Array(r);o[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},73811:function(e,t,a){a.d(t,{Z:function(){return p}});var n=a(67294),s=Object.defineProperty,r=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable,l=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a;function p({children:e,hidden:t,className:a}){return n.createElement("div",((e,t)=>{for(var a in t||(t={}))o.call(t,a)&&l(e,a,t[a]);if(r)for(var a of r(t))i.call(t,a)&&l(e,a,t[a]);return e})({role:"tabpanel"},{hidden:t,className:a}),e)}},73824:function(e,t,a){a.d(t,{Z:function(){return h}});var n=a(67294),s=a(54939),r=a(39670),o=a(86010),i="tabItem_LplD",l=Object.defineProperty,p=Object.defineProperties,u=Object.getOwnPropertyDescriptors,c=Object.getOwnPropertySymbols,g=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,m=(e,t,a)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,w=(e,t)=>{for(var a in t||(t={}))g.call(t,a)&&m(e,a,t[a]);if(c)for(var a of c(t))d.call(t,a)&&m(e,a,t[a]);return e};function f(e){var t,a,s;const{lazy:l,block:c,defaultValue:g,values:d,groupId:m,className:f}=e,h=n.Children.map(e.children,(e=>{if((0,n.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=null!=d?d:h.map((({props:{value:e,label:t,attributes:a}})=>({value:e,label:t,attributes:a}))),y=(0,r.lx)(b,((e,t)=>e.value===t.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===g?g:null!=(s=null!=g?g:null==(t=h.find((e=>e.props.default)))?void 0:t.props.value)?s:null==(a=h[0])?void 0:a.props.value;if(null!==v&&!b.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:x,setTabGroupChoices:k}=(0,r.UB)(),[P,S]=(0,n.useState)(v),j=[],{blockElementScrollPositionUntilNextRender:T}=(0,r.o5)();if(null!=m){const e=x[m];null!=e&&e!==P&&b.some((t=>t.value===e))&&S(e)}const N=e=>{const t=e.currentTarget,a=j.indexOf(t),n=b[a].value;n!==P&&(T(t),S(n),null!=m&&k(m,n))},I=e=>{let t=null;switch(e.key){case"ArrowRight":{const a=j.indexOf(e.currentTarget)+1;t=j[a]||j[0];break}case"ArrowLeft":{const a=j.indexOf(e.currentTarget)-1;t=j[a]||j[j.length-1];break}}null==t||t.focus()};return n.createElement("div",{className:"tabs-container"},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":c},f)},b.map((({value:e,label:t,attributes:a})=>{return n.createElement("li",(s=w({role:"tab",tabIndex:P===e?0:-1,"aria-selected":P===e,key:e,ref:e=>j.push(e),onKeyDown:I,onFocus:N,onClick:N},a),r={className:(0,o.Z)("tabs__item",i,null==a?void 0:a.className,{"tabs__item--active":P===e})},p(s,u(r))),null!=t?t:e);var s,r}))),l?(0,n.cloneElement)(h.filter((e=>e.props.value===P))[0],{className:"margin-vert--md"}):n.createElement("div",{className:"margin-vert--md"},h.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==P})))))}function h(e){const t=(0,s.Z)();return n.createElement(f,w({key:String(t)},e))}},25988:function(e,t,a){a.r(t),a.d(t,{assets:function(){return h},contentTitle:function(){return w},default:function(){return v},frontMatter:function(){return m},metadata:function(){return f},toc:function(){return b}});var n=a(3905),s=a(73824),r=a(73811),o=Object.defineProperty,i=Object.defineProperties,l=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,g=(e,t,a)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,d=(e,t)=>{for(var a in t||(t={}))u.call(t,a)&&g(e,a,t[a]);if(p)for(var a of p(t))c.call(t,a)&&g(e,a,t[a]);return e};const m={id:"test-auth",title:"Authentication"},w=void 0,f={unversionedId:"test-auth",id:"test-auth",title:"Authentication",description:"Tests written with Playwright execute in isolated clean-slate environments called browser contexts. Each test gets a brand new page created in a brand new context. This isolation model improves reproducibility and prevents cascading test failures.",source:"@site/docs/test-auth.mdx",sourceDirName:".",slug:"/test-auth",permalink:"/docs/next/test-auth",tags:[],version:"current",frontMatter:{id:"test-auth",title:"Authentication"},sidebar:"docs",previous:{title:"Assertions",permalink:"/docs/next/test-assertions"},next:{title:"Command line",permalink:"/docs/next/test-cli"}},h={},b=[{value:"Sign in with beforeEach",id:"sign-in-with-beforeeach",level:2},{value:"Reuse signed in state",id:"reuse-signed-in-state",level:2},{value:"Sign in via API request",id:"sign-in-via-api-request",level:3},{value:"Avoiding multiple sessions per account at a time",id:"avoiding-multiple-sessions-per-account-at-a-time",level:3},{value:"Multiple signed in roles",id:"multiple-signed-in-roles",level:2},{value:"Testing multiple roles together",id:"testing-multiple-roles-together",level:3},{value:"Testing multiple roles with POM fixtures",id:"testing-multiple-roles-with-pom-fixtures",level:3},{value:"Reuse the signed in page in multiple tests",id:"reuse-the-signed-in-page-in-multiple-tests",level:2}],y={toc:b};function v(e){var t,a=e,{components:o}=a,g=((e,t)=>{var a={};for(var n in e)u.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&p)for(var n of p(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=d(d({},y),g),i(t,l({components:o,mdxType:"MDXLayout"}))),(0,n.kt)("p",null,"Tests written with Playwright execute in isolated clean-slate environments called ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/browser-contexts"}),"browser contexts"),". Each test gets a brand new page created in a brand new context. This isolation model improves reproducibility and prevents cascading test failures."),(0,n.kt)("p",null,"Below are the typical strategies for implementing the signed-in scenarios."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",d({parentName:"li"},{href:"#sign-in-with-beforeeach"}),"Sign in with beforeEach")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",d({parentName:"li"},{href:"#reuse-signed-in-state"}),"Reuse signed in state")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",d({parentName:"li"},{href:"#multiple-signed-in-roles"}),"Multiple signed in roles")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",d({parentName:"li"},{href:"#reuse-the-signed-in-page-in-multiple-tests"}),"Reuse the signed in page in multiple tests"))),(0,n.kt)("h2",d({},{id:"sign-in-with-beforeeach"}),"Sign in with beforeEach"),(0,n.kt)("p",null,"This is the simplest way where each test signs in inside the ",(0,n.kt)("inlineCode",{parentName:"p"},"beforeEach")," hook. It also is the least efficient one in case the log in process has high latencies."),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"import { test } from '@playwright/test';\n\ntest.beforeEach(async ({ page }) => {\n  // Runs before each test and signs in each page.\n  await page.goto('https://github.com/login');\n  await page.locator('text=Login').click();\n  await page.locator('input[name=\"login\"]').fill('username');\n  await page.locator('input[name=\"password\"]').fill('password');\n  await page.locator('text=Submit').click();\n});\n\ntest('first', async ({ page }) => {\n  // page is signed in.\n});\n\ntest('second', async ({ page }) => {\n  // page is signed in.\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"const { test } = require('@playwright/test');\n\ntest.beforeEach(async ({ page }) => {\n  // Runs before each test and signs in each page.\n  await page.goto('https://github.com/login');\n  await page.locator('text=Login').click();\n  await page.locator('input[name=\"login\"]').fill('username');\n  await page.locator('input[name=\"password\"]').fill('password');\n  await page.locator('text=Submit').click();\n});\n\ntest('first', async ({ page }) => {\n  // page is signed in.\n});\n\ntest('second', async ({ page }) => {\n  // page is signed in.\n});\n")))),(0,n.kt)("p",null,"Redoing login for every test can slow down test execution. To mitigate that, reuse existing authentication state instead."),(0,n.kt)("h2",d({},{id:"reuse-signed-in-state"}),"Reuse signed in state"),(0,n.kt)("p",null,"Playwright provides a way to reuse the signed-in state in the tests. That way you can log in only once and then skip the log in step for all of the tests."),(0,n.kt)("p",null,"Create a new global setup script:"),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// global-setup.ts\nimport { chromium, FullConfig } from '@playwright/test';\n\nasync function globalSetup(config: FullConfig) {\n  const browser = await chromium.launch();\n  const page = await browser.newPage();\n  await page.goto('https://github.com/login');\n  await page.locator('input[name=\"login\"]').fill('user');\n  await page.locator('input[name=\"password\"]').fill('password');\n  await page.locator('text=Sign in').click();\n  // Save signed-in state to 'storageState.json'.\n  await page.context().storageState({ path: 'storageState.json' });\n  await browser.close();\n}\n\nexport default globalSetup;\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// global-setup.js\nconst { chromium } = require('@playwright/test');\n\nmodule.exports = async config => {\n  const browser = await chromium.launch();\n  const page = await browser.newPage();\n  await page.goto('https://github.com/login');\n  await page.locator('input[name=\"login\"]').fill('user');\n  await page.locator('input[name=\"password\"]').fill('password');\n  await page.locator('text=Sign in').click();\n  // Save signed-in state to 'storageState.json'.\n  await page.context().storageState({ path: 'storageState.json' });\n  await browser.close();\n};\n")))),(0,n.kt)("p",null,"Register global setup script in the Playwright configuration file:"),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// playwright.config.ts\nimport type { PlaywrightTestConfig } from '@playwright/test';\n\nconst config: PlaywrightTestConfig = {\n  globalSetup: require.resolve('./global-setup'),\n  use: {\n    // Tell all tests to load signed-in state from 'storageState.json'.\n    storageState: 'storageState.json'\n  }\n};\nexport default config;\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// playwright.config.js\n// @ts-check\n/** @type {import('@playwright/test').PlaywrightTestConfig} */\nconst config = {\n  globalSetup: require.resolve('./global-setup'),\n  use: {\n    // Tell all tests to load signed-in state from 'storageState.json'.\n    storageState: 'storageState.json'\n  }\n};\nmodule.exports = config;\n")))),(0,n.kt)("p",null,"Tests start already authenticated because we specify ",(0,n.kt)("inlineCode",{parentName:"p"},"storageState")," that was populated by global setup."),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"import { test } from '@playwright/test';\n\ntest('test', async ({ page }) => {\n  // page is signed in.\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"const { test } = require('@playwright/test');\n\ntest('test', async ({ page }) => {\n  // page is signed in.\n});\n")))),(0,n.kt)("div",d({},{className:"admonition admonition-note alert alert--secondary"}),(0,n.kt)("div",d({parentName:"div"},{className:"admonition-heading"}),(0,n.kt)("h5",{parentName:"div"},(0,n.kt)("span",d({parentName:"h5"},{className:"admonition-icon"}),(0,n.kt)("svg",d({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),(0,n.kt)("path",d({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),(0,n.kt)("div",d({parentName:"div"},{className:"admonition-content"}),(0,n.kt)("p",{parentName:"div"},"If you can log in once and commit the ",(0,n.kt)("inlineCode",{parentName:"p"},"storageState.json")," into the repository, you won't need the global setup at all, just specify the ",(0,n.kt)("inlineCode",{parentName:"p"},"storageState.json")," in Playwright Config as above and it'll be picked up.  However, periodically, you may need to update the ",(0,n.kt)("inlineCode",{parentName:"p"},"storageState.json")," file if your app requires you to re-authenticate after some amount of time. For example, if your app prompts you to sign in every week even if you're on the same computer/browser, you'll need to update ",(0,n.kt)("inlineCode",{parentName:"p"},"storageState.json")," at least this often."))),(0,n.kt)("h3",d({},{id:"sign-in-via-api-request"}),"Sign in via API request"),(0,n.kt)("p",null,"If your web application supports signing in via API, you can use ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/api/class-apirequestcontext",title:"APIRequestContext"}),"APIRequestContext")," to simplify sign in flow. Global setup script from the example above would change like this:"),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// global-setup.ts\nimport { request } from '@playwright/test';\n\nasync function globalSetup() {\n  const requestContext = await request.newContext();\n  await requestContext.post('https://github.com/login', {\n    form: {\n      'user': 'user',\n      'password': 'password'\n    }\n  });\n  // Save signed-in state to 'storageState.json'.\n  await requestContext.storageState({ path: 'storageState.json' });\n  await requestContext.dispose();\n}\n\nexport default globalSetup;\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// global-setup.js\nconst { request } = require('@playwright/test');\n\nmodule.exports = async () => {\n  const requestContext = await request.newContext();\n  await requestContext.post('https://github.com/login', {\n    form: {\n      'user': 'user',\n      'password': 'password'\n    }\n  });\n  // Save signed-in state to 'storageState.json'.\n  await requestContext.storageState({ path: 'storageState.json' });\n  await requestContext.dispose();\n}\n")))),(0,n.kt)("h3",d({},{id:"avoiding-multiple-sessions-per-account-at-a-time"}),"Avoiding multiple sessions per account at a time"),(0,n.kt)("p",null,"By default, Playwright Test runs tests in parallel. If you reuse a single signed-in state for all your tests, this usually leads to the same account being signed in from multiple tests at the same time. If this behavior is undesirable for your application, you can sign in with a different account in each ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/test-parallel#worker-processes"}),"worker process")," created by Playwright Test."),(0,n.kt)("p",null,"In this example we ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/test-fixtures#overriding-fixtures"}),"override ",(0,n.kt)("inlineCode",{parentName:"a"},"storageState")," fixture")," and ensure we only sign in once per worker, using ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/api/class-testinfo#test-info-worker-index"}),"testInfo.workerIndex")," to differentiate between workers."),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// fixtures.ts\nimport { test as baseTest } from '@playwright/test';\nexport { expect } from '@playwright/test';\n\nconst users = [\n  { username: 'user-1', password: 'password-1' },\n  { username: 'user-2', password: 'password-2' },\n  // ... put your test users here ...\n];\n\nexport const test = baseTest.extend({\n  storageState: async ({ browser }, use, testInfo) => {\n    // Override storage state, use worker index to look up logged-in info and generate it lazily.\n    const fileName = path.join(testInfo.project.outputDir, 'storage-' + testInfo.workerIndex);\n    if (!fs.existsSync(fileName)) {\n      // Make sure we are not using any other storage state.\n      const page = await browser.newPage({ storageState: undefined });\n      await page.goto('https://github.com/login');\n      // Create a unique username for each worker.\n      await page.locator('input[name=\"login\"]').fill(users[testInfo.workerIndex].username);\n      await page.locator('input[name=\"password\"]').fill(users[testInfo.workerIndex].password);\n      await page.locator('text=Sign in').click();\n      await page.context().storageState({ path: fileName });\n      await page.close();\n    }\n    await use(fileName);\n  },\n});\n\n// example.spec.ts\nimport { test, expect } from './fixtures';\n\ntest('test', async ({ page }) => {\n  // page is signed in.\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// fixtures.js\nconst { test: base } = require('@playwright/test');\n\nconst users = [\n  { username: 'user-1', password: 'password-1' },\n  { username: 'user-2', password: 'password-2' },\n  // ... put your test users here ...\n];\n\nexports.test = base.extend({\n  storageState: async ({ browser }, use, testInfo) => {\n    // Override storage state, use worker index to look up logged-in info and generate it lazily.\n    const fileName = path.join(testInfo.project.outputDir, 'storage-' + testInfo.workerIndex);\n    if (!fs.existsSync(fileName)) {\n      // Make sure we are not using any other storage state.\n      const page = await browser.newPage({ storageState: undefined });\n      await page.goto('https://github.com/login');\n      await page.locator('input[name=\"login\"]').fill(users[testInfo.workerIndex].username);\n      await page.locator('input[name=\"password\"]').fill(users[testInfo.workerIndex].password);\n      await page.locator('text=Sign in').click();\n      await page.context().storageState({ path: fileName });\n      await page.close();\n    }\n    await use(fileName);\n  },\n});\nexports.expect = base.expect;\n\n// example.spec.js\nconst { test, expect } = require('./fixtures');\n\ntest('test', async ({ page }) => {\n  // page is signed in.\n});\n")))),(0,n.kt)("h2",d({},{id:"multiple-signed-in-roles"}),"Multiple signed in roles"),(0,n.kt)("p",null,"Sometimes you have more than one signed-in user in your end to end tests. You can achieve that via logging in for these users multiple times in globalSetup and saving that state into different files."),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// global-setup.ts\nimport { chromium, FullConfig } from '@playwright/test';\n\nasync function globalSetup(config: FullConfig) {\n  const browser = await chromium.launch();\n  const adminPage = await browser.newPage();\n  // ... log in\n  await adminPage.context().storageState({ path: 'adminStorageState.json' });\n\n  const userPage = await browser.newPage();\n  // ... log in\n  await userPage.context().storageState({ path: 'userStorageState.json' });\n  await browser.close();\n}\n\nexport default globalSetup;\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// global-setup.js\nconst { chromium } = require('@playwright/test');\n\nmodule.exports = async config => {\n  const browser = await chromium.launch();\n  const adminPage = await browser.newPage();\n  // ... log in\n  await adminPage.context().storageState({ path: 'adminStorageState.json' });\n\n  const userPage = await browser.newPage();\n  // ... log in\n  await userPage.context().storageState({ path: 'userStorageState.json' });\n  await browser.close();\n};\n")))),(0,n.kt)("p",null,"After that you can specify the user to use for each test file or each test group:"),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"import { test } from '@playwright/test';\n\ntest.use({ storageState: 'adminStorageState.json' });\n\ntest('admin test', async ({ page }) => {\n  // page is signed in as admin.\n});\n\ntest.describe(() => {\n  test.use({ storageState: 'userStorageState.json' });\n\n  test('user test', async ({ page }) => {\n    // page is signed in as a user.\n  });\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"const { test } = require('@playwright/test');\n\ntest.use({ storageState: 'adminStorageState.json' });\n\ntest('admin test', async ({ page }) => {\n  // page is signed in as amin.\n});\n\ntest.describe(() => {\n  test.use({ storageState: 'userStorageState.json' });\n\n  test('user test', async ({ page }) => {\n    // page is signed in as a user.\n  });\n});\n")))),(0,n.kt)("h3",d({},{id:"testing-multiple-roles-together"}),"Testing multiple roles together"),(0,n.kt)("p",null,"If you need to test how multiple authenticated roles interact together, use multiple ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/api/class-browsercontext",title:"BrowserContext"}),"BrowserContext"),"s and ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/api/class-page",title:"Page"}),"Page"),"s with different storage states in the same test. Any of the methods above to create multiple storage state files would work."),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"import { test } from '@playwright/test';\n\ntest('admin and user', async ({ browser }) => {\n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".\n  const adminContext = await browser.newContext({ storageState: 'adminStorageState.json' });\n  const adminPage = await adminContext.newPage();\n\n  // userContext and all pages inside, including userPage, are signed in as \"user\".\n  const userContext = await browser.newContext({ storageState: 'userStorageState.json' });\n  const userPage = await userContext.newPage();\n\n  // ... interact with both adminPage and userPage ...\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"const { test } = require('@playwright/test');\n\ntest('admin and user', async ({ browser }) => {\n  // adminContext and all pages inside, including adminPage, are signed in as \"admin\".\n  const adminContext = await browser.newContext({ storageState: 'adminStorageState.json' });\n  const adminPage = await adminContext.newPage();\n\n  // userContext and all pages inside, including userPage, are signed in as \"user\".\n  const userContext = await browser.newContext({ storageState: 'userStorageState.json' });\n  const userPage = await userContext.newPage();\n\n  // ... interact with both adminPage and userPage ...\n});\n")))),(0,n.kt)("h3",d({},{id:"testing-multiple-roles-with-pom-fixtures"}),"Testing multiple roles with POM fixtures"),(0,n.kt)("p",null,"If many of your tests require multiple authenticated roles from within the same test, you can introduce fixtures for each role. Any of the methods above to create multiple storage state files would work."),(0,n.kt)("p",null,"Below is an example that ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/test-fixtures#creating-a-fixture"}),"creates fixtures")," for two ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/test-pom"}),"Page Object Models")," - admin POM and user POM. It assumes ",(0,n.kt)("inlineCode",{parentName:"p"},"adminStorageState.json")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"userStorageState.json")," files were created."),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// fixtures.ts\nimport { test as base, Page, Browser, Locator } from '@playwright/test';\nexport { expect } from '@playwright/test';\n\n// Page Object Model for the \"admin\" page.\n// Here you can add locators and helper methods specific to the admin page.\nclass AdminPage {\n  // Page signed in as \"admin\".\n  page: Page;\n\n  constructor(page: Page) {\n    this.page = page;\n  }\n\n  static async create(browser: Browser) {\n    const context = await browser.newContext({ storageState: 'adminStorageState.json' });\n    const page = await context.newPage();\n    return new AdminPage(page);\n  }\n}\n\n// Page Object Model for the \"user\" page.\n// Here you can add locators and helper methods specific to the user page.\nclass UserPage {\n  // Page signed in as \"user\".\n  page: Page;\n\n  // Example locator pointing to \"Welcome, User\" greeting.\n  greeting: Locator;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.greeting = page.locator('#greeting');\n  }\n\n  static async create(browser: Browser) {\n    const context = await browser.newContext({ storageState: 'userStorageState.json' });\n    const page = await context.newPage();\n    return new UserPage(page);\n  }\n}\n\n// Declare the types of your fixtures.\ntype MyFixtures = {\n  adminPage: AdminPage;\n  userPage: UserPage;\n};\n\n// Extend base test by providing \"adminPage\" and \"userPage\".\n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.\nexport const test = base.extend<MyFixtures>({\n  adminPage: async ({ browser }, use) => {\n    await use(await AdminPage.create(browser));\n  },\n  userPage: async ({ browser }, use) => {\n    await use(await UserPage.create(browser));\n  },\n});\n\n\n// example.spec.ts\n// Import test with our new fixtures.\nimport { test, expect } from './fixtures';\n\n// Use adminPage and userPage fixtures in the test.\ntest('admin and user', async ({ adminPage, userPage }) => {\n  // ... interact with both adminPage and userPage ...\n  await adminPage.page.screenshot();\n  await expect(userPage.greeting).toHaveText('Welcome, User');\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),'// fixtures.js\nconst { test: base } = require(\'@playwright/test\');\n\n// Page Object Model for the "admin" page.\n// Here you can add locators and helper methods specific to the admin page.\nclass AdminPage {\n  constructor(page) {\n    // Page signed in as "admin".\n    this.page = page;\n  }\n\n  static async create(browser) {\n    const context = await browser.newContext({ storageState: \'adminStorageState.json\' });\n    const page = await context.newPage();\n    return new AdminPage(page);\n  }\n}\n\n// Page Object Model for the "user" page.\n// Here you can add locators and helper methods specific to the user page.\nclass UserPage {\n  constructor(page) {\n    // Page signed in as "user".\n    this.page = page;\n    // Example locator pointing to "Welcome, User" greeting.\n    this.greeting = page.locator(\'#greeting\');\n  }\n\n  static async create(browser) {\n    const context = await browser.newContext({ storageState: \'userStorageState.json\' });\n    const page = await context.newPage();\n    return new UserPage(page);\n  }\n}\n\n// Extend base test by providing "adminPage" and "userPage".\n// This new "test" can be used in multiple test files, and each of them will get the fixtures.\nexports.test = base.extend({\n  adminPage: async ({ browser }, use) => {\n    await use(await AdminPage.create(browser));\n  },\n  userPage: async ({ browser }, use) => {\n    await use(await UserPage.create(browser));\n  },\n});\nexports.expect = base.expect;\n\n// example.spec.ts\n// Import test with our new fixtures.\nconst { test, expect } = require(\'./fixtures\');\n\n// Use adminPage and userPage fixtures in the test.\ntest(\'admin and user\', async ({ adminPage, userPage }) => {\n  // ... interact with both adminPage and userPage ...\n  await adminPage.page.screenshot();\n  await expect(userPage.greeting).toHaveText(\'Welcome, User\');\n});\n')))),(0,n.kt)("h2",d({},{id:"reuse-the-signed-in-page-in-multiple-tests"}),"Reuse the signed in page in multiple tests"),(0,n.kt)("p",null,"Although discouraged, sometimes it is necessary to sacrifice the isolation and run a number of tests in the same page. In that case, you can log into that page once in ",(0,n.kt)("inlineCode",{parentName:"p"},"beforeAll")," and then use that same page in all the tests. Note that you need to run these tests serially using ",(0,n.kt)("inlineCode",{parentName:"p"},"test.describe.serial")," in order to achieve that:"),(0,n.kt)(s.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// example.spec.ts\n\nimport { test, Page } from '@playwright/test';\n\ntest.describe.configure({ mode: 'serial' });\n\nlet page: Page;\n\ntest.beforeAll(async ({ browser }) => {\n  // Create page once and sign in.\n  page = await browser.newPage();\n  await page.goto('https://github.com/login');\n  await page.locator('input[name=\"user\"]').fill('user');\n  await page.locator('input[name=\"password\"]').fill('password');\n  await page.locator('text=Sign in').click();\n});\n\ntest.afterAll(async () => {\n  await page.close();\n});\n\ntest('first test', async () => {\n  // page is signed in.\n});\n\ntest('second test', async () => {\n  // page is signed in.\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",d({parentName:"pre"},{className:"language-js"}),"// example.spec.js\n// @ts-check\n\nconst { test } = require('@playwright/test');\n\ntest.describe.configure({ mode: 'serial' });\n\n/** @type {import('@playwright/test').Page} */\nlet page;\n\ntest.beforeAll(async ({ browser }) => {\n  // Create page yourself and sign in.\n  page = await browser.newPage();\n  await page.goto('https://github.com/login');\n  await page.locator('input[name=\"user\"]').fill('user');\n  await page.locator('input[name=\"password\"]').fill('password');\n  await page.locator('text=Sign in').click();\n});\n\ntest.afterAll(async () => {\n  await page.close();\n});\n\ntest('first test', async () => {\n  // page is signed in.\n});\n\ntest('second test', async () => {\n  // page is signed in.\n});\n")))),(0,n.kt)("div",d({},{className:"admonition admonition-note alert alert--secondary"}),(0,n.kt)("div",d({parentName:"div"},{className:"admonition-heading"}),(0,n.kt)("h5",{parentName:"div"},(0,n.kt)("span",d({parentName:"h5"},{className:"admonition-icon"}),(0,n.kt)("svg",d({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),(0,n.kt)("path",d({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),(0,n.kt)("div",d({parentName:"div"},{className:"admonition-content"}),(0,n.kt)("p",{parentName:"div"},"You can also use ",(0,n.kt)("inlineCode",{parentName:"p"},"storageState")," property when you are creating the ",(0,n.kt)("a",d({parentName:"p"},{href:"/docs/next/api/class-browser#browser-new-page"}),"browser.newPage([options])")," in order to pass it an existing logged in state."))))}v.isMDXComponent=!0}}]);